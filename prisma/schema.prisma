generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("PRISMA_DATABASE_URL")
  directUrl = env("DATABASE_URL")
}

model User {
  id                   String    @id @default(cuid())
  name                 String?
  email                String    @unique
  emailVerified        DateTime?
  image                String?
  whiteLabelEnabled    Boolean   @default(false)
  companyName          String?
  primaryColor         String    @default("#8B5CF6")
  logo                 String?
  plan                 Plan      @default(FREE)
  planExpires          DateTime?
  stripeCustomerId     String?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  billingCycleEnd      DateTime?
  billingCycleStart    DateTime  @default(now())
  paypalCustomerId     String?   @unique
  paypalSubscriptionId String?   @unique
  subscriptionStatus   String    @default("free")
  cancelledAt          DateTime? // When subscription was cancelled
  subscriptionEndDate  DateTime? // When access actually ends (end of billing period)
  website              String?
  supportEmail         String?
  
  // Email verification and trial tracking
  trialStartDate       DateTime?
  trialEndDate         DateTime?
  trialUsed            Boolean   @default(false)
  trialType            String?   // 'EMAIL' | 'PAYPAL' | null
  signupIp             String?
  welcomeEmailSent     Boolean   @default(false)
  signupFlow           String?   // 'FREE' | 'PAID_TRIAL' | null
  
  clients              Client[]
  payments             Payment[]
  reports              Report[]

  @@map("users")
}

model Payment {
  id                   String   @id @default(cuid())
  userId               String
  paypalOrderId        String   @unique
  paypalSubscriptionId String?
  amount               Decimal  @db.Decimal(10, 2)
  currency             String   @default("USD")
  status               String
  plan                 Plan
  metadata             Json?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([paypalSubscriptionId])
  @@map("payments")
}

model Client {
  id                           String    @id @default(cuid())
  name                         String
  domain                       String
  contactEmail                 String?
  contactName                  String?
  googleSearchConsoleConnected Boolean   @default(false)
  googleAnalyticsConnected     Boolean   @default(false)
  searchConsolePropertyUrl     String?
  googleAnalyticsPropertyId    String?
  searchConsoleRefreshToken    String?
  analyticsRefreshToken        String?
  lastReportGenerated          DateTime?
  totalReportsGenerated        Int       @default(0)
  createdAt                    DateTime  @default(now())
  updatedAt                    DateTime  @updatedAt
  userId                       String
  gaPropertyId                 String?
  googleAccessToken            String?
  googleConnectedAt            DateTime?
  googleRefreshToken           String?
  googleTokenExpiry            DateTime?
  gscSiteUrl                   String?
  dataFetchStatus              String?
  ga4PropertyId                String?
  ga4PropertyName              String?
  gscSiteName                  String?
  customMetrics                Json?     // Stores array of custom metric objects
  lastDataFetch                DateTime?
  user                         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  reports                      Report[]

  @@index([userId])
  @@index([domain])
  @@map("clients")
}

model Report {
  id                    String       @id @default(cuid())
  title                 String
  status                ReportStatus @default(PENDING)
  data                  Json?
  pdfUrl                String?
  pdfSize               Int?
  processingStartedAt   DateTime?
  processingCompletedAt DateTime?
  errorMessage          String?
  generationTimeMs      Int?
  createdAt             DateTime     @default(now())
  updatedAt             DateTime     @updatedAt
  clientId              String
  userId                String
  client                Client       @relation(fields: [clientId], references: [id], onDelete: Cascade)
  user                  User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("reports")
}

model ApiUsage {
  id                 String   @id @default(cuid())
  userId             String
  endpoint           String
  method             String
  requestSize        Int?
  responseSize       Int?
  responseTime       Int?
  statusCode         Int
  rateLimitRemaining Int?
  cost               Float    @default(0.0)
  timestamp          DateTime @default(now())

  @@index([userId])
  @@index([timestamp])
  @@map("api_usage")
}

model WebhookEvent {
  id            String        @id @default(cuid())
  eventType     String
  eventData     Json
  status        WebhookStatus @default(PENDING)
  attempts      Int           @default(0)
  maxAttempts   Int           @default(3)
  nextAttemptAt DateTime?
  lastError     String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  @@index([status])
  @@index([nextAttemptAt])
  @@map("webhook_events")
}

model AppSetting {
  id          String   @id @default(cuid())
  key         String   @unique
  value       Json
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("app_settings")
}

model VerificationToken {
  id        String   @id @default(cuid())
  token     String   @unique
  email     String
  expires   DateTime
  createdAt DateTime @default(now())
  
  @@index([email])
  @@index([token])
  @@map("verification_tokens")
}

enum Plan {
  FREE
  STARTER
  PROFESSIONAL
  AGENCY
}

enum ReportStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum WebhookStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}
